<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Solidity Learning</title>
    <link href="/2022/04/26/Solidity-Learning/"/>
    <url>/2022/04/26/Solidity-Learning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>博客的 Markdown 编辑器暂不支持 Solidity 语法高亮，为了更舒服的阅读代码，可以去 <a href="https://github.com/Blockchain-Engineer-Learning/Solidity-Learning">我的GitHub仓库</a></p></blockquote><h1 id="Hello-Solidity"><a href="#Hello-Solidity" class="headerlink" title="Hello Solidity"></a>Hello Solidity</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章内容参考 <a href="https://docs.soliditylang.org/">Solidity官方文档</a> 和其他开发者的学习笔记。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Solidity是一门面向合约的、为实现智能合约而创建的高级编程语言。</p><p>设计的目的是能在以太坊虚拟机（EVM）上运行。</p><p>Solidity是静态类型语言，支持继承、库和复杂的用户定义类型等。</p><blockquote><p>静态类型语言的类型检查是在运行前的编译阶段，比如 C#、Java 等都是静态类型语言。</p></blockquote><p>推荐使用的IDE——Remix</p><blockquote><p>Remix 是一个基于 Web 浏览器的 IDE，它可以让你编写 Solidity 智能合约，然后部署并运行该智能合约。</p></blockquote><p>适合写Solidity的软件——VS Code（装插件）</p><blockquote><p>实际开发时使用 VS Code 和 Remix 混合使用，相辅相成</p></blockquote><h2 id="语法学习"><a href="#语法学习" class="headerlink" title="语法学习"></a>语法学习</h2><p>下面是一个简单“代币”的例子，直观地理解Solidity合约结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity &gt;=0.7.0 &lt;0.9.0;<br><br>contract Coin &#123;<br>address public minter;<br>mapping (address =&gt; uint) public balances;<br><br>event Sent(address from, address to, uint amount);<br><br>constructor() &#123;<br>minter = msg.sender;<br>&#125;<br><br>// 铸币<br>function mint(address receiver, uint amount) public &#123;<br>require(msg.sender == minter);<br>require(amount &lt; 1e60);<br>balances[receiver] += amount;<br>&#125;<br><br>// 转账<br>function send(address receiver, uint amount) public &#123;<br>require(amount &lt;= balances[msg.sender], &quot;Insufficient balance.&quot;);<br>balances[msg.sender] -= amount;<br>balances[receiver] += amount;<br>emit Sent(msg.sender, receiver, amount);<br>&#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h3 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h3><h4 id="SPDX-License-Identifier"><a href="#SPDX-License-Identifier" class="headerlink" title="SPDX License Identifier"></a>SPDX License Identifier</h4><p>如果源代码可用，则可以更好地建立对智能合约的信任。由于提供源代码总是涉及版权方面的法律问题，Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符。每个源文件都应以说明其许可证的注释开头：<code>// SPDX-License-Identifier: MIT</code></p><p>如果您不想指定许可证或源代码不是开源的，请使用特殊值 <code>UNLICENSED</code>。</p><blockquote><p>对于个人开发者，人们往往忽视这行代码，因为不写也不影响运行，但如果你将来打算从事合约开发的工作，应该引起注意，培养好习惯。</p></blockquote><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>版本标识，pragmatic information 的简称，用于启用某些编译器检查。Solidity 语言更新快，以此来避免因为Solidity更新后导致的不兼容和语法变动错误。只对本文件有效，如果使用 <code>import</code> 导入其他文件，版本标识不会被导入，而是采用工作的文件自身的版本标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.5.2;<br>Copy<br></code></pre></td></tr></table></figure><p>这里表示 0.5.2-0.6.0（不含0.6.0）的版本</p><h4 id="导入其他文件"><a href="#导入其他文件" class="headerlink" title="导入其他文件"></a>导入其他文件</h4><p>语法类似 <code>JavaScript</code> （ES6之后）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;filename&quot;;<br>Copy<br></code></pre></td></tr></table></figure><p>此语句将<strong>导入”filename”中所有的全局符号到当前作用域</strong>中，这种方式已经<strong>不建议使用</strong>，因为它会无法预测地污染当前命名空间。</p><p>更好的方式是明确导入的具体符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import * as symbolName from &quot;filename&quot;;<br>Copy<br></code></pre></td></tr></table></figure><p>所有的全局符号都以 <code>symbolName.symbol</code> 格式提供。</p><p>等价形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;filename&quot; as symbolName;<br>Copy<br></code></pre></td></tr></table></figure><p>如果存在命名冲突，可以在导入时重命名符号。下面的代码创建了新的全局符号 <code>temp</code> 和 <code>symbol2</code> ，引用的<code>symbol1</code>和<code>symbol2</code>来自”filename”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &#123;symbol as temp, symbol2&#125; from &quot;filename&quot;;<br>Copy<br></code></pre></td></tr></table></figure><p>支持从网上导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;<br><br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;<br>Copy<br></code></pre></td></tr></table></figure><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径形式同 Linux ，但要避免使用<code>..</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;./filename&quot; as symbolName;<br>Copy<br></code></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释 <code>//</code> ，多行注释 <code>/*......*/</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 单行注释<br><br>/*<br>多行注释<br>*/<br>Copy<br></code></pre></td></tr></table></figure><p>还可以使用 natspec 注释。</p><p>它们是用 <code>///</code> 开头或 <code>/**......*/</code> 书写。可在注释中使用 Doxygen 样式的标签来文档化，使注释更容易读和理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.4.21 &lt;0.9.0;<br><br>/**<br> * @title Shape calculator<br> * @author Confucian<br> */<br>contract ShapeCalculator &#123;<br>/// @dev 求矩形面积<br> /// @param w 矩形宽度<br> /// @param h 矩形高度<br> /// @return s 求得面积<br>/// @return p 求得周长<br>function rectangle(uint w, uint h) public pure returns (uint s, uint p) &#123;<br>s = w * h;<br>p = 2 * (w + h);<br>&#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>在 Solidity 语言中，合约类似于 Java（面向对象编程语言）中的<strong>类</strong>。</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永远地存储在合约存储中的值（上链的），有数据类型和可见性属性。在函数体外面的都是 <code>storage</code> 全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.4.0 &lt;0.9.0;<br><br>contract TinyStorage &#123;<br>uint storedXlbData;// 状态变量<br>// ...<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>代码的可执行单元。函数通常定义在合约内部，但也可定义在合约外。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;0.7.0 &lt;0.9.0;<br><br>contract TinyAuction &#123;<br>    function Mybid() public payable &#123; // 定义函数<br>        // ...<br>    &#125;<br>&#125;<br><br>// 定义在合约外<br>function helper(uint x) pure returns (uint) &#123;<br>    return x * 2;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>函数调用可以在合约内部或外部，且函数对其他合约有不同程度的可见性。</p><p>函数可以接受参数和返回值。</p><h4 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器</h4><p>用来修饰函数（给函数加一些条件约束）的一个小部件，自己定义，方便代码复用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract MyPurchase &#123;<br>address public seller;<br><br>modifier onlySeller() &#123;<br>require(<br>msg.sender == seller,<br>&quot;Only seller can call this.&quot;<br>);<br>_;<br>&#125;<br><br>function abort() public onlySeller &#123;<br>// ...<br>&#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>其中 <code>_;</code> 表示函数体代码的位置，一定要记得写！</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件 Event 是能方便地调用以太坊虚拟机日志功能的接口。</p><blockquote><p>Dapp中，常通过监听事件来更新页面</p></blockquote><ul><li>定义事件：<code>event 事件名(参数)</code></li><li>触发事件：<code>emit 事件名(实参)</code> 注意对应的参数类型要匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TinyAuction &#123;<br>event HighestBidIncreased(address bidder, uint amount);<br><br>function bid() public payable &#123;<br>// ...<br>emit HighestBidIncreased(msg.sender, msg.value);<br>&#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>结构体是可以将几个变量分组的自定义类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TinyBallot &#123;<br>struct Voter &#123;<br>uint weight;<br>bool voted;<br>address delegate;<br>uint vote;<br>&#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举可用来创建由一定数量的“常量值”构成的自定义函数类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Upchain &#123;<br>enum State &#123; Created, Locked, InValid &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ethereum</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPN</title>
    <link href="/2022/04/26/VPN/"/>
    <url>/2022/04/26/VPN/</url>
    
    <content type="html"><![CDATA[<h1 id="机场推荐"><a href="#机场推荐" class="headerlink" title="机场推荐"></a>机场推荐</h1><p>发现了个性价比不错的机场，安利给大家。</p><h2 id="辣条"><a href="#辣条" class="headerlink" title="辣条"></a>辣条</h2><p>全平台使用，不限设备数量</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>网址：<a href="https://latiao.club/#/register?code=Vd9RRH17">https://latiao.club/#/register?code=Vd9RRH17</a></p><p>我的邀请码：<strong>Vd9RRH17</strong></p><blockquote><p>点击上述网址会自动填充我的邀请码</p></blockquote><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>进入“<strong>购买订阅</strong>”界面后，选择你想购买的套餐，点击“<strong>立即订阅</strong>”。</p><p><img src="/../IMG/VPN/VPN_1.png"></p><p>进入购买界面后（此处以 <strong>9G</strong> 为例）</p><p>右边“<strong>订单总额</strong>”上面输入 <strong>LT888</strong> 并点击“<strong>验证</strong>”，即可享受 <strong>6折</strong> 优惠。（优惠码是一个博主分享的）</p><p><img src="/../IMG/VPN/VPN_2.png"></p><p>根据自己的需求选择好“<strong>付款周期</strong>”后，点击“<strong>下单</strong>”进入（支付宝）付款页面。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>详细使用方法参考左侧“<strong>使用文档</strong>”。</p><p><img src="/../IMG/VPN/VPN_3.png"></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interpretation of ERC20</title>
    <link href="/2022/04/25/ERC20/"/>
    <url>/2022/04/25/ERC20/</url>
    
    <content type="html"><![CDATA[<blockquote><p>博客的 Markdown 编辑器暂不支持 Solidity 语法高亮，为了更好阅读代码，可以去 <a href="https://github.com/Blockchain-Engineer-Learning/Contract-Interpretation/tree/main/ERC20">我的GitHub仓库</a> 。</p></blockquote><h1 id="ERC20解读"><a href="#ERC20解读" class="headerlink" title="ERC20解读"></a>ERC20解读</h1><p>参考 <a href="https://docs.openzeppelin.com/contracts/4.x/erc20">OpenZepplin文档</a> 和 <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">以太坊官方开发者文档</a>，结合自己的理解。</p><h2 id="什么是ERC20"><a href="#什么是ERC20" class="headerlink" title="什么是ERC20"></a>什么是ERC20</h2><p>ERC20（Ethereum Request for Comments 20）一种代币标准。<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">EIP-20</a> 中提出。</p><p>ERC20 代币合约追踪同质化（可替代）代币：任何一个代币都完全等同于任何其他代币；没有任何代币具有与之相关的特殊权利或行为。这使得 ERC20 代币可用于交换货币、投票权、质押等。</p><h2 id="为什么要遵守ERC20"><a href="#为什么要遵守ERC20" class="headerlink" title="为什么要遵守ERC20"></a>为什么要遵守ERC20</h2><p>EIP-20 中的动机：</p><blockquote><p>允许以太坊上的任何代币被其他应用程序（从钱包到去中心化交易所）重新使用的标准接口。</p></blockquote><p>以太坊上的所有应用都默认支持 ERC20 ，如果你想自己发币，那么你的代码必须遵循 ERC20 标准，这样钱包（如MetaMask）等应用才能将你的币显示出来。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>需要实现以下函数和事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs solidity">function name() public view returns (string)<br>function symbol() public view returns (string)<br>function decimals() public view returns (uint8)<br>function totalSupply() public view returns (uint256)<br>function balanceOf(address _owner) public view returns (uint256 balance)<br>function transfer(address _to, uint256 _value) public returns (bool success)<br>function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)<br>function approve(address _spender, uint256 _value) public returns (bool success)<br>function allowance(address _owner, address _spender) public view returns (uint256 remaining)<br><br>event Transfer(address indexed _from, address indexed _to, uint256 _value)<br>event Approval(address indexed _owner, address indexed _spender, uint256 _value)<br></code></pre></td></tr></table></figure><p>使用 OpenZeppllin 提供的库能够轻松快速地构建 ERC20 Token 。</p><h3 id="快速构建"><a href="#快速构建" class="headerlink" title="快速构建"></a>快速构建</h3><p>这是一个 GLD token 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// contracts/GLDToken.sol<br>// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br><br>contract GLDToken is ERC20 &#123;<br>    constructor(uint256 initialSupply) ERC20(&quot;Gold&quot;, &quot;GLD&quot;) &#123;<br>        _mint(msg.sender, initialSupply);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，我们定义代币的发行量和代币名称及符号。</p><h3 id="IERC20"><a href="#IERC20" class="headerlink" title="IERC20"></a>IERC20</h3><p>先来看下 ERC20 的接口（IERC20），这方便我们在开发中直接定义 ERC20 代币。</p><p>同样地，OpenZepplin 为我们提供了相应的库，方便开发者导入即用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br></code></pre></td></tr></table></figure><p><strong>EIP 中定义的 ERC20 标准接口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>interface IERC20 &#123;<br>event Transfer(address indexed from, address indexed to, uint256 value);<br>event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>function totalSupply() external view returns (uint256);<br>function balanceOf(address account) external view returns (uint256);<br>function transfer(address to, uint256 amount) external returns (bool);<br>function allowance(address owner, address spender) external view returns (uint256);<br>function approve(address spender, uint256 amount) external returns (bool);<br>function transferFrom(<br>address from,<br>address to,<br>uint256 amount<br>) external returns (bool);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逐一分析"><a href="#逐一分析" class="headerlink" title="逐一分析"></a>逐一分析</h4><p>函数：</p><ul><li><code>totalSupply()</code> ：返回总共的代币数量。</li><li><code>balanceOf(address account)</code> ：返回 <code>account</code> 地址拥有的代币数量。</li><li><code>transfer(address to, uint256 amount)</code> ：将 <code>amount</code> 数量的代币发送给 <code>to</code> 地址，返回布尔值告知是否执行成功。触发 <code>Transfer</code> 事件。</li><li><code>allowance(address owner, address spender)</code> ：返回授权花费者 <code>spender</code> 通过 <code>transferFrom</code> 代表所有者花费的剩余代币数量。默认情况下为零。当 <code>approve</code> 和 <code>transferFrom</code> 被调用时，值将改变。</li><li><code>approve(address spender, uint256 amount)</code> ：授权 <code>spender</code> 可以花费 <code>amount</code> 数量的代币，返回布尔值告知是否执行成功。触发 <code>Approval</code> 事件。</li><li><code>transferFrom(address from, address to, uint256 amount)</code> ：将 <code>amount</code> 数量的代币从 <code>from</code> 地址发送到 <code>to</code> 地址，返回布尔值告知是否执行成功。触发 <code>Transfer</code> 事件。</li></ul><p>事件（定义中的 <code>indexed</code> 便于查找过滤）：</p><ul><li><code>Transfer(address from, address to, uint256 value)</code> ：当代币被一个地址转移到另一个地址时触发。注意：转移的值可能是 0 。</li><li><code>Approval(address owner, address spender, uint256 value)</code> ：当代币所有者授权别人使用代币时触发，即调用 <code>approve</code> 方法。</li></ul><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>一般除了上述必须实现的函数外，还有一些别的方法：</p><ul><li><code>name()</code> ：返回代币名称</li><li><code>symbol()</code> ：返回代币符号</li><li><code>decimals()</code> 返回代币小数点后位数</li></ul><h3 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h3><p>来看下 ERC20 代币具体是怎么写的。</p><p>同样，OpenZepplin 提供了现成的合约代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br></code></pre></td></tr></table></figure><p>这里贴一个GitHub源码链接 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">OpenZepplin ERC20</a></p><h4 id="函数概览"><a href="#函数概览" class="headerlink" title="函数概览"></a>函数概览</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor(name_, symbol_)<br>name()<br>symbol()<br>decimals()<br>totalSupply()<br>balanceOf(account)<br>transfer(to, amount)<br>allowance(owner, spender)<br>approve(spender, amount)<br>transferFrom(from, to, amount)<br>increaseAllowance(spender, addedValue)<br>decreaseAllowance(spender, subtractedValue)<br>_transfer(from, to, amount)<br>_mint(account, amount)<br>_burn(account, amount)<br>_approve(owner, spender, amount)<br>_spendAllowance(owner, spender, amount)<br>_beforeTokenTransfer(from, to, amount)<br>_afterTokenTransfer(from, to, amount)<br></code></pre></td></tr></table></figure><p><strong>事件（同 IERC20）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">Transfer(from, to, value)<br>Approval(owner, spender, value)<br></code></pre></td></tr></table></figure><h4 id="逐一分析-1"><a href="#逐一分析-1" class="headerlink" title="逐一分析"></a>逐一分析</h4><ul><li><code>constructor(string name, string symbol)</code> ：设定代币的名称和符号。<code>decimals</code> 默认是 18 ，要修改成不同的值你应该重载它。这两个值是不变的，只在构造时赋值一次。</li><li><code>name()</code> ：返回代币的名称。</li><li><code>symbol()</code> ：返回代币的符号，通常是名称的缩写。</li><li><code>decimals()</code> ：返回小数点后位数，通常是 18 ，模仿 Ether 和 wei 。要更改就重写它。</li></ul><p><code>totalSupply()、balanceOf(address account)、transfer(address to, uint256 amount)、 allowance(address owner, address spender)、approve(address spender, uint256 amount)、transferFrom(address from, address to, uint256 amount)</code> 都参考 IERC20 。</p><ul><li><p><code>increaseAllowance(address spender, uint256 addedValue)</code> ：以原子的方式增加 <code>spender</code> 额度。返回布尔值告知是否执行成功，触发 <code>Approval</code> 事件。</p></li><li><p><code>_transfer(address from, address to, uint256 amount)</code> ：转账。这个内部函数相当于 <code>transfer</code> ，可以用于例如实施自动代币费用，削减机制等。触发 <code>Transfer</code> 事件。</p></li><li><p><code>_mint(address account, uint256 amount)</code> ：铸造 <code>amount</code> 数量的代币给 <code>account</code> 地址，增加总发行量。触发 <code>Transfer</code> 事件，其中参数 <code>from</code> 是零地址。</p></li><li><p><code>_burn(address account, uint256 amount)</code> ：从 <code>account</code> 地址中烧毁 <code>amount</code> 数量的代币，减少总发行量。触发 <code>Transfer</code> 事件，其中参数 <code>to</code> 是零地址。</p></li><li><p><code>_approve(address owner, uint256 spender, uint256 amount)</code> ：设定允许 <code>spender</code> 花费 <code>owner</code> 的代币数量。这个内部函数相当于 <code>approve</code> ，可以用于例如为某些子系统设置自动限额等。</p></li><li><p><code>spendAllowance(address owner, address spender, uint256 amount)</code> ：花费 <code>amount</code> 数量的 <code>owner</code> 授权 <code>spender</code> 的代币。在无限 allowance 的情况下不更新 allowance 金额。如果没有足够的余量，则恢复。可能触发 <code>Approval</code> 事件。</p></li><li><p><code>_beforeTokenTransfer(address from, address to, uint256 amount)</code> ：在任何代币转账前的 Hook 。它包括铸币和烧毁。调用条件：</p><ul><li>当 <code>from</code> 和 <code>to</code> 都不是零地址时，<code>from</code> 手里 <code>amount</code> 数量的代币将发送给 <code>to</code> 。</li><li>当 <code>from</code> 是零地址时，将给 <code>to</code> 铸造 <code>amount</code> 数量的代币。</li><li>当 <code>to</code> 是零地址时，<code>from</code> 手里 <code>amount</code> 数量的代币将被烧毁。</li><li><code>from</code> 和 <code>to</code> 不能同时为零地址。</li></ul></li><li><p><code>_afterTokenTransfer(address from, address to, uint256 amount)</code> ：在任何代币转账后的 Hook 。它包括铸币和烧毁。调用条件：</p><ul><li>当 <code>from</code> 和 <code>to</code> 都不是零地址时，<code>from</code> 手里 <code>amount</code> 数量的代币将发送给 <code>to</code> 。</li><li>当 <code>from</code> 是零地址时，将给 <code>to</code> 铸造 <code>amount</code> 数量的代币。</li><li>当 <code>to</code> 是零地址时，<code>from</code> 手里 <code>amount</code> 数量的代币将被烧毁。</li><li><code>from</code> 和 <code>to</code> 不能同时为零地址。</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ERC20 代码中的 <code>_transfer</code>、<code>_mint</code>、<code>_burn</code>、<code>_approve</code>、<code>_spendAllowance</code>、<code>_beforeTokenTransfer</code>、<code>_afterTokenTransfer</code> 都是 <code>internal</code> 函数（其余为 <code>public</code> ），也就是说它们只能被派生合约调用。</p><h2 id="从零开始，自己动手"><a href="#从零开始，自己动手" class="headerlink" title="从零开始，自己动手"></a>从零开始，自己动手</h2><h3 id="1-编写IERC20"><a href="#1-编写IERC20" class="headerlink" title="1.编写IERC20"></a>1.编写IERC20</h3><p><a href="https://github.com/Blockchain-Engineer-Learning/Contract-Interpretation/blob/main/ERC20/contracts/IERC20.sol">IERC20.sol</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>pragma solidity ^0.8.0;<br><br>interface IERC20 &#123;<br>    /// @dev 总发行量<br>    function totoalSupply() external view returns (uint256);<br>    /// @dev 查看地址余额<br>    function balanceOf(address account) external view returns (uint256);<br>    /// @dev 单地址转账<br>    function transfer(address account, uint256 amount) external returns (bool);<br>    /// @dev 查看被授权人代表所有者花费的代币余额<br>    function allowance(address owner, address spender) external view returns (uint256);<br>    /// @dev 授权别人花费你拥有的代币<br>    function approve(address spender, uint256 amount) external returns (bool);<br>    /// @dev 双地址转账<br>    function transferFrom(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) external returns (bool);<br><br>    /// @dev 发生代币转移时触发<br>    event Transfer(address indexed from, address indexed to, uint256 value);<br>    /// @dev 授权时触发<br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-加上Metadata"><a href="#2-加上Metadata" class="headerlink" title="2.加上Metadata"></a>2.加上Metadata</h3><p><a href="https://github.com/Blockchain-Engineer-Learning/Contract-Interpretation/blob/main/ERC20/contracts/IERC20Metadata.sol">IERC20Metadata.sol</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>pragma solidity ^0.8.0;<br><br>import &quot;IERC20.sol&quot;;<br><br>interface IERC20Metadata is IERC20 &#123;<br>    /// @dev 代币名称<br>    function name() external view returns (string memory);<br>    /// @dev 代币符号<br>    function symbol() external view returns (string memory);<br>    /// @dev 小数点后位数<br>    function decimals() external view returns (uint8);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-编写ERC20"><a href="#3-编写ERC20" class="headerlink" title="3.编写ERC20"></a>3.编写ERC20</h3><p><a href="https://github.com/Blockchain-Engineer-Learning/Contract-Interpretation/blob/main/ERC20/contracts/ERC20.sol">ERC20.sol</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>pragma solidity ^0.8.0;<br><br>import &quot;./IERC20.sol&quot;;<br>import &quot;./IERC20Metadata.sol&quot;;<br><br>contract ERC20 is IERC20, IERC30Metadata &#123;<br>    // 地址余额<br>    mapping(address =&gt; uint256) private _balances;<br>    // 授权地址余额<br>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;<br><br>    uint256 private _totalSupply;<br><br>    string private _name;<br>    string private _symbol;<br><br>    /// @dev 设定代币名称符号<br>    constructor(string memory name_, string memory symbol_) &#123;<br>        _name = name_;<br>        _symbol = symbol_;<br>    &#125;<br><br>    function name() public view virtual override returns (string memory) &#123;<br>        return _name;<br>    &#125;<br><br>    function symbol() public view virtual override returns (string memory) &#123;<br>        return _symbol;<br>    &#125;<br><br>    /// @dev 小数点位数一般为 18<br>    function decimals() public view virtual override returns (uint8) &#123;<br>        return 18;<br>    &#125;<br><br>    function totalSupply() public view virtual  override returns (uint256) &#123;<br>        return _totalSupply;<br>    &#125;<br><br>    function balanceOf(address account) public view virtual override returns (uint256) &#123;<br>        return _balances[account];<br>    &#125;<br><br>    function transfer(address to, uint256 amount) public virtual override returns (bool) &#123;<br>        address owner = msg.sender;<br>        _transfer(owner, to, amount);<br>        return true;<br>    &#125;<br><br>    function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;<br>        return _allowances[owner][spender];<br>    &#125;<br><br>    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;<br>        address owner = msg.sender;<br>        _approve(owner, spender, amount);<br>        return true;<br>    &#125;<br><br>    function transferFrom(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) public virtual override returns (bool) &#123;<br>        address spender = msg.sender;<br>        _spendAllowance(from, spender, amount);<br>        _transfer(from, to, amount);<br>        return true;<br>    &#125;<br><br>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;<br>        address owner = msg.sender;<br>        _approve(owner, spender, _allowances[owner][spender] + addedValue);<br>        return true;<br>    &#125;<br><br>    function decreaseAllowance(address spender, uint256 substractedValue) public virtual returns (bool) &#123;<br>        address owner = msg.sender;<br>        uint256 currentAllowance = _allowances[owner][spender];<br>        require(currentAllowance &gt;= substractedValue, &quot;ERC20: decreased allowance below zero&quot;);<br>        unchecked &#123;<br>            _approval(owner, spender, currentAllowance - substractedValue);<br>        &#125;<br>        return true;<br>    &#125;<br><br>    function _transfer(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);<br>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);<br><br>        _beforeTokenTransfer(from, to, amount);<br><br>        uint256 fromBalance = _balances[from];<br>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);<br>        unchecked &#123;<br>            _balances[from] = fromBalance - amount;<br>        &#125;<br>        _balances[to] += amount;<br><br>        emit Transfer(from, to, amount);<br><br>        _afterTokenTransfer(from, to, amount);<br>    &#125;<br><br>    function _mint(address account, uint256 amount) internal virtual &#123;<br>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);<br><br>        _beforeTokenTransfer(address(0), account, amount);<br><br>        _totalSupply += amount;<br>        _balances[account] += amount;<br>        emit Transfer(address(0), account, amount);<br><br>        _afterTokenTransfer(address(0), account, amount);<br>    &#125;<br><br>    function _burn(address account, uint256 amount) internal virtual &#123;<br>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);<br><br>        _beforeTokenTransfer(account, address(0), amount);<br><br>        uint256 accountBalance = _balances[account];<br>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);<br>        unchecked &#123;<br>            _balances[account] = accountBalance - amount;<br>        &#125;<br>        _totalSupply -= amount;<br><br>        emit Transfer(account, address(0), amount);<br><br>        _afterTokenTransfer(account, address(0), amount);<br>    &#125;<br><br>    function _approve(<br>        address owner,<br>        address spender,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);<br>        require(spender != address(0), &quot;ERC20: approve  to the zero address&quot;);<br><br>        _allowances[owner][spender];<br>        emit Approval(owner, spender, amount);<br>    &#125;<br><br>    function _spendAllowance(<br>        address owner,<br>        address spender,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        uint256 currentAllowance = allowance(owner, spender);<br>        if (currentAllowance != type(uint256).max) &#123;<br>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);<br>            unchecked &#123;<br>                _approve(owner, spender, currentAllowance - amount);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    function _beforeTokenTransfer(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) internal virtual &#123;&#125;<br><br>    function _afterTokenTransfer(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) internal virtual &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ERC20 其实就是一种最常见的代币标准，它明确了同质化代币的经典功能并规范了开发者编写 token 时的代码，从而方便各种应用适配。</p>]]></content>
    
    
    <categories>
      
      <category>Ethereum</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Contracts</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
